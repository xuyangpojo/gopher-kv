##### [0001] NoSQL数据库
键值型: Redis
文档型: MongoDB(JSON格式)，容易数据混乱。
列族数据库: 按列存储，操作性能不如行数据库。
图数据库: 擅长各种图论算法。
时序数据库: 针对海量高频监控类数据插入进行分析。
向量数据库: 存储向量值，进行大规模近似最近临搜索。

##### [0002] ZSet 过多时的性能问题
进行分桶/分片/冷热分离，查询整体时需要聚合结果。Redis有提供内存压缩算法。

##### [0003] 缓存穿透问题
缓存穿透即空值查询问题，可以设置布隆过滤器拦截请求，以及范围过滤恶意请求。

##### [0004] 布隆过滤器
在位图中对存在的元素做多个哈希函数置位，查询时所有对应位为`1`表示可能存在，出现`0`则数据一定不存在。可能误判，放过空请求，但是不会拦截真请求。缺点是不支持删除元素。

##### [0005] 过滤器删除元素问题
1. 定时重建布隆过滤器，可以分片分桶以减少删整个过滤器的开销。
2. 双重布隆过滤器: 一个记录有一个记录无，但是误判率更大。
2. 布隆过滤器加计数: 每个位添加count计数，添加时+1删除时-1，需要存储额外信息。
3. 布谷鸟过滤器: 双哈希函数，双冲突时踢一个到其他位置(鸠占鹊巢)，但插入性能可能波动。

##### [0005] 缓存击穿问题
缓存击穿即热点 Key 失效问题。可以设置分布式互斥锁暂时进行阻塞，也可以设置物理永不过期，设置逻辑过期时间，逻辑过期进行更新，其他线程暂时读取旧数据。

##### [0006] 缓存雪崩问题
缓存雪崩即大量 Key 同时失效(Redis服务宕机也是同样效果)问题。解决方法有设置随机过期时间、引入除 Redis 外的多级缓存服务，使用 Redis 哨兵集群保证高可用性，流控进行服务降级熔断。

##### [0007] 大Key问题
单个 Key 的 Value 过大，如内存占用过大的 String，元素数量过大的 Hash/ZSet 等。
可以拆分成多个小 Key，进行数据分桶，优化数据的序列化压缩算法，设置合理过期时间等。

##### [0008] RDB和AOF备份的区别
RDB是内存快照，AOF是写操作历史日志。默认应该两个同时使用。

##### [0009] 过期删除策略
惰性删除：访问时发现过期再删除，CPU友好，内存不友好。
定期删除：定期抽取一定数量的 Key 查看是否过期并删除，CPU不友好，内存友好。
Redis 两种过期删除策略一起使用，但可能有过期的漏网之鱼。

##### [0010] 内存淘汰策略 `maxmemory-policy`​
`noeviction`禁止写入策略(默认)：数据不丢失，但是会导致服务不可写。
`allkeys-lru`/`allkeys-lfu`/`allkeys-random`全Key的LRU/LCU/随机淘汰、
`volatile-lru`/`volatile-lfu`/`volatile-random`有过期时间Key的LRU/LCU淘汰。

##### [0011] Redis 单线程高并发实现方式 (IO多路复用)
为防止同步阻塞，使用中间的IO多路复用模块监听多个Socket状态。

##### [0012] Redis与MySQL(在读写操作下的)数据一致性
旁路缓存(Cache Aside)：写时先写数据库再删缓存，防止先删缓存时被读操作再写入。
延迟双删：写 MySQL 后删除 Redis 失效缓存，延迟等待后再删一次 Redis 失效缓存。
写穿(Write Through)：写入缓存，再由缓存写数据库，读操作只读缓存。
写回(Write Back)：写入缓存，再异步写入数据库，读操作只读缓存。
旁路缓存可能出现 主MySQL 已更新，读操作把未更新的 从MySQL 写会缓存的问题，延迟双删是对旁路缓存的优化。
写穿比写回的一致性高，但是性能开销更大。
还可以订阅 Binlog 维护消息队列保证最终一致性，但是实时性较弱。

##### [0013] Redis 主从集群
主从模式：主节点负责数据写入和同步到从节点，从节点负责数据读取。
短期重连=增量同步：主节点维护复制积压缓冲区，根据复制偏移量恢复从节点部分数据。
长期重连=全量同步：主节点传递RDB快照和生成RDB期间收到的新的写命令。

##### [0014] Redis 哨兵 (Sentinel) 模式 (监控主从集群)
多个哨兵 ping 监控主从节点状态。单哨兵认定为主观下线，多个哨兵认定客观下线，
主节点故障时启动故障转移，Raft 协议选举 从->主

##### [0015] Redis 分片集群
普通哈希算法: %N，N发生变化后所有数据需要重新计算分配并迁移。
一致性哈希算法: 维护一个哈希结果环，值顺时针找到第一个节点作为归属，N改变时迁移量小。
哈希槽(官方): 分配 Slot 槽位，每个 Redis 服务负责其中的部分槽位的数据。

##### [0016] Redis 数据类型
Redis的key为`String`类型
value基本类型`String`、`List`、`Hash`、`Set`、`ZSet(SortedSet)`
value稀有类型`Bitmaps(位图: 如用户签到记录)`、`HyberLoglog(集合总数统计: 如日活月活)`、
`Geospatial(地理位置与空间计算)`、`Stream(流: 用于消息队列)`、`Bitfield(位域: 范围位操作)`

##### [0017] Redis底层数据结构(C语言编写)
SDS (Simple Dynamic String): 存储长度，自动扩容，结尾保留`\0`以兼容C函数。
Dict: 渐进式Rehash，扩容时保留新旧两个哈希表，防止迁移重计算哈希值时阻塞。
ZipList: 压缩链表，连续内存存储，无额外指针开销。
SkipList: 跳表，ZSet底层结构，更加灵活。
 - 跳表的范围查找和增删操作比起B+数更简便，需要维护的指针数少，不用做树节点的分裂合并。
 - 跳表的内存占用更加灵活，比起B+树的内存空间浪费更小。

##### [0017] Redisson 分布式锁
`setnx`由于Redis单线程，其作为单个命令天然保证原子性，可作为锁使用
[不可重入问题] 使用哈希结构`hsetnx`，用线程ID+UUID作为field识别线程信息，
            使用count锁计数器，加锁一次++，释放一次--
[误释放问题] 先判断ID信息再释放，两步命令使用LUA脚本保证原子性
[无限阻塞问题] 给锁添加过期时间，使得线程挂掉后锁能被自动释放
[看门狗机制] 在1/3(默认10s处)时间自动续时间，防止业务还在进行中就超时释放了锁，
           看门狗设置为业务线程的守护线程，业务线程挂掉后JVM自动终止看门狗，防止无限续锁
[分布式主从集群] 要求加锁给所有主节点(红锁机制:加锁50%以上主节点保证互斥性)确保锁消息一致性。